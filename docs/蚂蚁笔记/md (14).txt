原贴地址：[http://blog.leanote.com/post/dawnmagnet/c8deab0f58d7](http://blog.
leanote.com/post/dawnmagnet/c8deab0f58d7)
# 题目
![title](https://leanote.com/api/file/getImage?fileId=60949935ab644101db00057
3)
# 思路分析
这个题目就算我们暴力做，也只是O(n)的复杂度，而且题目的数据给的也不是很大，暴
力一定非常快。（窃喜
于是我们暴力做了一下，很快啊，就出来了，直接就AC了，还只用了0ms。
```rust
impl Solution {
    pub fn xor_operation(n: i32, mut start: i32) -> i32 {
        let mut res = 0;
        for i in 0..n {
            res ^= (start + 2 * i);
        }
        res
    }
}
```
那么请问我们还有继续往下优化的必要吗？
当然有。
往下优化，复杂度可能是O(1)或者O(lgn)，一般来说，我们要有基本的概念。
怎么样才能让复杂度到达O(1)呢？一般来说是答案是有规律的，套个公式什么的直接就
能出答案。
怎么样才能让复杂度到达O(lgn)呢？一般来说是通过除2来构造的，除2之前之后获取一
些信息，再组合组合。这样才能得到O(lgn)的答案。
给大家一些做题目时候的小tips，遇到这种数列找规律的题目，先打印出来看看，是否
符合规律（基本上都能肉眼观察出来）
```text
以下是初始值为0的时候前20项
0 2 6 0 8 2 14 0 16 2 22 0 24 2 30 0 32 2 38 
以下是初始值为1的时候前20项
1 2 7 0 9 2 15 0 17 2 23 0 25 2 31 0 33 2 39 
以下是初始值为2的时候前20项
2 6 0 8 2 14 0 16 2 22 0 24 2 30 0 32 2 38 0 
以下是初始值为3的时候前20项
3 6 1 8 3 14 1 16 3 22 1 24 3 30 1 32 3 38 1 
```
不难看出，以任何数字为初始值开始都是有规律可循的。而且每一个都是4项为一组。
|初始值|规律|
--|--
0| \* 2 * 0
1| \* 2 * 0
2| \2 * 0 *
3| \3 * 1 *
不难看出都是有规律可循的，而只要定位了这些规律点，就非常好求每一项了，比如求
起始为0的第五项，我们只需要在里面找到第五项的位置，就是2左边的位置，再用2去异
或2 * n 也就是2 ^ 10 = 
8，按照这个方法，只要我们确定了特征点，在去反推任何位置的数字，只需要O(1)的时
间，最多不会超过三步