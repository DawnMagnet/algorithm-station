大家好!今天给大家带来的是第87题扰乱字符串，做了这么久题解了，终于遇到了一道困
难题，还是挺有难度的。
原贴地址：http://leanote.com/blog/post/60790900ab644104e700636b
## 题目
使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：
如果字符串的长度为 1 ，算法停止
如果字符串的长度 > 1 ，执行下述步骤：
在一个随机下标处将字符串分割成两个非空的子字符串。即，如果已知字符串 s 
，则可以将其分成两个子字符串 x 和 y ，且满足 s = x + y 。
随机 决定是要「交换两个子字符串」还是要「保持这两个子字符串的顺序不变」。即，
在执行这一步骤之后，s 可能是 s = x + y 或者 s = y + x 。
在 x 和 y 这两个子字符串上继续从步骤 1 开始递归执行此算法。
给你两个 长度相等 的字符串 s1 
和 s2，判断 s2 是否是 s1 的扰乱字符串。如果是，返回 true ；否则，返回 false 
。
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/scramble-string
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
## 思路分析
这道题一看就很复杂。最关键的是没有思路。  
遇到没有思路的时候，我们就再读一遍题目。如果还是没有思路，我们就再读一遍题目
，总会有的。
题目中提到了一个关键操作，交换子字符串。像我们都写了这么多题目了，好的思路没
有，最基础的思路（模拟题目的中的行No.87 
扰乱字符串(每日一题)为）还是有的（主要是因为水平不够）。  
那么我们就开始假设，如何通过一个变化过字符串还原出原来没变化的字符串呢，这个
好像有点困难，因为对我们来说，我们并不知道他交换的是哪个，还原也就无从谈起。 
 
那如果不能还原的话，我们就只能从原字符串向后推了。模拟的思路有两种，一种是dfs
，一种是dp。其实没有什么本质区别，dp和记忆化dfs其实是等价的。那么我们就假设使
用DP，那么我们必须得有转移方程吧。  
为了模拟交换子字符串的思路，我们在对答案进行求解的时候，我们也不知道它是哪个
子字符串进行交换的，所以我们得进行一次循环来查找它的交换点，假设示例1，源字符
串是"great",变化之后的是"rgeat",我们假设一个检查位ck,让这个ck从1位置向后移动
 - 第一次，原字符串被分成"g"和"reat",那么如何匹配后面的字符串呢，当然还有两种
 情况，一种是（"g"和"r"匹配，"reat"和"geat"匹配），另一种是（"g"和"t"匹配，"r
 eat"和"rgat"匹配），当然，这两种都失败了。
 - 第二次，原字符串被分成"gr"和"eat",那么如何匹配后面的字符串呢，当然还有两种
 情况，一种是（"gr"和"rg"匹配，"eat"和"eat"匹配），另一种是（"gr"和"at"匹配，
 "eat"和"rge"匹配），当然，第一种是成功的，我们一眼都能看出来，可是计算机看不
 出来啊，我们必须告诉它"gr"和"rg"是匹配的并且"eat"和"eat"是匹配的，这就产生了
 子问题，子问题是求解动态规划的关键
 鉴于此，我们可以写出我们的状态转移方程：
```
dp[i][j][k] |= (
     (dp[i][j][ck] && dp[i + ck][j + ck][k - ck]) ||
     (dp[i][j + k - ck][ck] && dp[i + ck][j][k - ck]));