大家好！今天给大家带来的是力扣第81题81. 搜索旋转排序数组 II。
原贴地址：http://leanote.com/blog/post/606d9d79ab644172650003ed
## 题目
已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。
在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 
旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., 
nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 
处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。
给你 旋转后 的数组 nums 和一个整数 target 
，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 
中存在这个目标值 target ，则返回 true ，否则返回 false 。
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
## 思路分析
这道题一看特别有规律，因为是一个有序数组被打乱，而且是从一个节点打乱。我们只
需找出这个节点就可以恢复之前的有序数组，那么我们只需要使用一次二分查找就可以
找出来这个数字是否存在了。  
但是我们思考一个问题，我们寻找这个节点用的是什么方法呢？必须是一个O(nlgn)的方
法吧，要不然我们为何不直接使用O(n)的遍历去寻找呢？所以我们确定了我们的思路，
就是先使用二分查找找到原数组被打乱的位置，还原出原来的数组，再对原数组进行一
次二分查找定位我们的target。  
思路很美好，可是我们没有写过这种奇奇怪怪的二分耶       
那怎么办呢，我们就得思考一下这个二分如何操作了。
我们先做出一个公认的定义：**转折点**，就是该数组被打断的节点，也就是原数组的
末尾
我们举一个例子：
假设该数组是[7,8,2,3,4,5,6]
他的**转折点**位于8的位置
按照二分的操作，我们先取出一个中间值，对比一下，有三种情况  
> n[left]==n[mid]这种情况我们没法区分转折点在哪里，所以我们只能使用O(n)的方法
进行寻找，即让left节点向右单步移动
---
> n[left] < n[mid]这种情况来看，mid以左的部分是有序的，转折点可能在mid及mid的
右方。所以我们得分两种情况讨论：
> > 1.nums[start] <= target < 
nums[mid]这就说明target有可能出现的地方只能是mid的左边，我们对左边进行二分(ri
ght = mid - 1)
2.否则我们就对右边进行二分(left = mid + 1)
---
> n[left] > n[mid]这种情况来看，mid以右的部分是有序的，转折点可能在mid及mid的
左方。所以我们还是得分两种情况讨论：
> > 1.nums[mid] <= target < 
nums[right]这就说明target有可能出现的地方只能是mid的右边，我们对右边进行二分(
left = mid + 1)