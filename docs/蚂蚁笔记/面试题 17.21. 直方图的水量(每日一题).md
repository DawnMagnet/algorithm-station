大家好!今天给大家带来的是LeetCode面试题17.21 直方图的水量
原贴地址：[曙光磁铁的博客](http://leanote.com/blog/post/6066cb51ab64417533000
635)
## 题目
给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少
水量?直方图的宽度为 1。
上面是由数组 `[0,1,0,2,1,0,1,3,2,1,2,1]` 表示的直方图，在这种情况下，可以接 6 
个单位的水（蓝色部分表示水）
![](https://leanote.com/api/file/getImage?fileId=606729f5ab6441753300071b)
![?](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainw
atertrap.png)
示例:
```
输入: [0,1,0,2,1,0,1,3,2,1,2,1]
输出: 6
```
## 思路分析
大家一开始看这种题目可能会无从下手,但是其实不用担心,这种题目往往有它的数学规
律.我们首先假设一个场景.
![](https://img1.baidu.com/it/u=3905823688,3353011219&fm=26&fmt=auto&gp=0.jpg
)
这是一个木桶,想必大家在生活中都见过木桶,也听说过[木桶效应](https://baike.baid
u.com/item/%E6%9C%A8%E6%A1%B6%E6%95%88%E5%BA%94/870962?fr=aladdin).
而在本题中,我们可以将装水想象成一个水桶,如果我们要对一个格子装水,**限制其最大
乘水量的因素只有:这个格子左边的桶沿(左边的最大值)和右边的桶沿(右边的最大值)中
的<big>小的那一边</big>**(因为这是一个二维的桶)，这就是核心思路。
沿着这个核心思路，我们继续分析。获取每个格子的左右的最大值分别需要O(n)的时间
。如果我们在对每个格子进行遍历的时候才去计算这个数据，那我们最终的时间就是O(n
^2)。所以这种办法的耗时太长了。如果我们在一开始就计算出所有的格子的左右最大值
，因为这个数组是不会改变的，所以这个最大值也不会随着程序的运行而改变，我们就
只需在程序的开始时计算一次。这样整体的时间复杂度就被降低到O(n)，大大降低了程
序运行的时间。
下面是第一种方法的C++代码
```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        if (n == 0) return 0;
        vector<int> ltop = {height[0]}, rtop = {height[n - 1]};
        for (int i = 1; i < n; ++i) {
            ltop.push_back(max(ltop.back(), height[i]));
            rtop.push_back(max(rtop.back(), height[n - 1 - i]));
        }
        reverse(rtop.begin(), rtop.end());
        int ret = 0;
        for (int i = 0; i < n; ++i) ret += min(ltop[i], rtop[i]) - height[i];
        return ret;