原帖地址：[http://blog.leanote.com/post/dawnmagnet/7](http://blog.leanote.com
/post/dawnmagnet/7)
![title](https://leanote.com/api/file/getImage?fileId=608f50abab64417a6c00344
0)
# 思路分析
五一也要继续营业呀！
整数反转，就是取出来一位再乘上一位呀！
我们把两个整数（输入整数和答案）想象成两个栈，从输入出栈，向答案入栈，就能得
到最终的答案了。
出栈的方法就是先对10 mod获得出栈元素，再除10出栈。
假设输入是1234567
12345 -> %10 = 5 -> /10 = 1234（出栈成功）
76 -> *10 = 760 -> +5 = 765（入栈成功）
所以总的来说就是这么一个流程，非常简单，唯一需要判断的就是溢出。
那么有可能溢出的地方一定是在入栈的地方，答案=答案*10+出栈元素答案=答案*10+出
栈元素，这里会出现溢出的情况，所以我们一定要在这一步时做一个判断.
答案=答案*10+出栈元素是否超出了32位整数的极限($-2^{31},2^{31} - 1$) 
但我们需要注意的一点是，环境中不允许存储64位整数，所以我们先计算再判断就有可
能溢出，导致错误，所以我们选择先判断再计算的方法，先通过不等式移项乘除来获取
这个不等式的值，将不等式转换为(res < i32::MIN / 10 || res > i32::MAX / 
10)，这样就不会出现溢出的风险了。
### Rust代码
```rust
impl Solution {
    pub fn reverse(mut x: i32) -> i32 {
        let mut res = 0;
        while x != 0 {
            if res < i32::MIN / 10 || res > i32::MAX / 10 {
                return 0;
            }
            res *= 10;
            res += x % 10;
            x /= 10;
        }
        res
    }
}
```
### C++代码
```cpp
class Solution {
public:
    int reverse(int x) {
        int res = 0;
        while (x != 0) {
            if (res < INT_MIN / 10 || res > INT_MAX / 10) {
                return 0;
            }
            res *= 10;
            res += x % 10;
            x /= 10;