原贴地址：[http://blog.leanote.com/post/dawnmagnet/lc930](http://blog.leanote
.com/post/dawnmagnet/lc930)
# 题目
<p>给你一个二元数组 <code>nums</code> ，和一个整数 <code>goal</code> 
，请你统计并返回有多少个和为 <code>goal</code> 的<strong> 非空</strong> 
子数组。</p>
<p><strong>子数组</strong> 是数组的一段连续部分。</p>
<p>&nbsp;</p>
<p><strong>示例 1：</strong></p>
<pre><strong>输入：</strong>nums = [1,0,1,0,1], goal = 2
<strong>输出：</strong>4
<strong>解释：</strong>
有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>nums = [0,0,0,0,0], goal = 0
<strong>输出：</strong>15
</pre>
<p>&nbsp;</p>
<p><strong>提示：</strong></p>
<ul>
    <li><code>1 &lt;= nums.length &lt;= 3 * 10<sup>4</sup></code></li>
    <li><code>nums[i]</code> 不是 <code>0</code> 就是 <code>1</code></li>
    <li><code>0 &lt;= goal &lt;= nums.length</code></li>
</ul>
# 思路分析
本题也是一个比较常规的题目，首先我们拿暴力的思路想一想，如果暴力，应该需要$O(
N^2)$甚至$O(N^3)$，一定是过不了的，能过的只有$O(N)$的算法。  
那么我们就要运用题目中给我们的条件。子数组，有一个特征，就是连续，而对于我们
来说，子数组最常见的快速遍历方法就是前缀和或者后缀和，因为连续，所以相当于只
要我们求出来了前缀和或者后缀和，我们能在$O(1)$的时间内求出一个特定连续子数组
的和。
假设我们求的是前缀和，获得了前缀和数组prefix，然后我们获得了一个特定的位置a，
我们可以获得a这个位置到数组开头的总和，现在我们要求另外一个b，这个b小于a，而
且`prefix[a] - prefix[b] == 
goal`，这个促使我们换了一个角度来思考，这个等式也可以写成`prefix[b] = 
prefix[a] - goal`那么就相当于我们要在a之前的prefix数组中找到一个值等于prefix[
a] - goal的这么一个prefix[b]，而在数组中找特定值的数据结构，我们就都会了，一
定是HashMap（哈希表）。