原贴地址：[http://blog.leanote.com/post/dawnmagnet/lc203](http://blog.leanote
.com/post/dawnmagnet/lc203)
# 题目
给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> 
，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 
<strong>新的头节点</strong> 。
<p>&nbsp;</p>
<p><strong>示例 1：</strong></p>
<img style="width: 500px; height: 142px;" 
src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" 
alt="">
<pre><strong>输入：</strong>head = [1,2,6,3,4,5,6], val = 6
<strong>输出：</strong>[1,2,3,4,5]
</pre>
<p><strong>示例 2：</strong></p>
<pre><strong>输入：</strong>head = [], val = 1
<strong>输出：</strong>[]
</pre>
<p><strong>示例 3：</strong></p>
<pre><strong>输入：</strong>head = [7,7,7,7], val = 7
<strong>输出：</strong>[]
</pre>
<p>&nbsp;</p>
<p><strong>提示：</strong></p>
<ul>
    <li>列表中的节点在范围 <code>[0, 10<sup>4</sup>]</code> 内</li>
    <li><code>1 &lt;= Node.val &lt;= 50</code></li>
    <li><code>0 &lt;= k &lt;= 50</code></li>
</ul>
# 思路分析
本题的难点就在于对链表的操作，如果这个链表是一个形式如示例3的链表，删除完之后
可能会连原先的head节点都会被删除，但是如果我们捏着head不放，根本就没法删head
，怎么办呢。
这里就会说到一个常用的做链表题的手段了，就是添加watch节点。
原来是7->7->7->7->null
添加了watch之后 变成了watch->7->7->7->7->null
这样操作以后，我们就不用担心对之前的head节点做什么操作了，因为head已经变成了
一个普通的节点，无需顾虑。操作完之后，我们不返回之前的head，因为head可能已经
不知道去哪儿了。所以我们返回watch->next即可，不管这个链表处理完是什么样，watc
h都不会对链表的操作产生影响，这也是为什么它叫watch，因为它只是起一个辅助作用
。