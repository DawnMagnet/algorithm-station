原帖地址：[http://blog.leanote.com/post/dawnmagnet/No.993-二叉树的堂兄弟节点]
(http://blog.leanote.com/post/dawnmagnet/No.993-%E4%BA%8C%E5%8F%89%E6%A0%91%E
7%9A%84%E5%A0%82%E5%85%84%E5%BC%9F%E8%8A%82%E7%82%B9)
# 题目
![title](https://leanote.com/api/file/getImage?fileId=60a28657ab64411fb00018d
f)
# 思路分析
堂兄节点存在一些基本的条件
- 深度相同
- 父节点不同
我们只需要获得了题目中给入的两个节点的深度信息和父亲信息，我们就可以判断它是
不是堂兄节点。
获得深度信息，我们得遍历一整遍二叉树，获取两个节点的该信息就得获取两遍整棵二
叉树。那么有一种办法只需要遍历一遍即可，就是BFS，广度优先搜索。
为什么说遍历一次即可获得答案呢，因为题目中给入的两个节点有可能有两种情况，即
是否在同一个深度，如果在同一个深度，就有可能是堂兄节点，如果不在同一个深度，
一定不可能是堂兄节点。
而我们知道，BFS对于树的遍历是按照层来的，也就是层序遍历。所以我们按照这个特点
，就可以设计出来一个算法，如果我们遍历到了一层，只出现了一个给入的节点，那么
直接返回false，因为两个节点不在同一层。如果在同一层，就再判断一下是否是同一个
父节点添加的即可。
### C++代码
```
class Solution {
public:
    bool isCousins(TreeNode* root, int x, int y) {
        vector<TreeNode *> v = {root};
        int appeared = 0;
        while (v.size()) {
            vector<TreeNode *> nxt;
            for (auto & node : v) {
                int appeared_tmp = 0;
                auto deal = [&](TreeNode* node_t){
                    if (node_t) {
                        if (node_t->val == x || node_t->val == y) 
                        appeared_tmp++;
                        nxt.push_back(node_t);
                    }
                };
                deal(node->left);
                deal(node->right);
                if (appeared_tmp == 2) return false;
                appeared += appeared_tmp;
            }
            if (appeared == 1) return false;
            else if (appeared == 2) return true;
            v = move(nxt);
        }
        return true;