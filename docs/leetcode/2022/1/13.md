# 13日 No.747 至少是其他数字两倍的最大数
给你一个整数数组 nums ，其中总是存在 唯一的 一个最大整数 。

请你找出数组中的最大元素并检查它是否 至少是数组中每个其他数字的两倍 。如果是，则返回 最大元素的下标 ，否则返回 -1 。



示例 1：

    输入：nums = [3,6,1,0]
    输出：1
    解释：6 是最大的整数，对于数组中的其他整数，6 大于数组中其他元素的两倍。6 的下标是 1 ，所以返回 1 。
示例 2：

    输入：nums = [1,2,3,4]
    输出：-1
    解释：4 没有超过 3 的两倍大，所以返回 -1 。
示例 3：

    输入：nums = [1]
    输出：0
    解释：因为不存在其他数字，所以认为现有数字 1 至少是其他数字的两倍。
 

提示：

- 1 <= nums.length <= 50
- 0 <= nums[i] <= 100
- nums 中的最大元素是唯一的


来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 思路分析

本题的思路非常简单，因为我们首先要找到最大整数，然后去判断这个最大整数是否是所有其他数字的两倍，因为一旦找到了最大整数，我们最需要去判断的也就是第二大的整数与最大整数的关系，因为一旦第二大的整数的两倍小于等于最大整数，说明剩余的所有数字也都满足这个条件。

那么我们遍历一遍即可同时获得最大整数与第二大整数的值，具体的遍历方法是使用两个变量`first`和`second`来表示最大数字与第二大数字的下标（**因为我们最后要返回的是下标**），在遍历的过程中，做以下几个事情
1. 首先去判断一个数字是否大于`first`下标对应的数字，如果更大那么说明第一大的数字需要更换为当前的数字
2. 如果大于`second`下标对应的数字且小于`first`下标对应的数字，那么就说明第二大的值可以替换成当前的数字
3. 如果都不大于，那么就无事发生

在这种情况下，遍历一遍就可以同时获得第一大数字与第二大数字的下标，然后我们再将其进行比较，也就是比较第一大数字与第二大数字的两倍哪个更大从而获得答案。

当然在此处也要考虑一些特殊情况，如数组长度只有1，和下标的初始值如何取。这种东西都可以在实践中积累经验。在此处，我使用`usize::MAX`也就是`usize`类型的最大值来标记未初始化的数字。所以我也在相对应的判断条件中加入了`first == usize::MAX`等条件，如果`first`没有取到有效值，我们就优先给其赋值

# Rust代码
```rust
impl Solution {
    pub fn dominant_index(nums: Vec<i32>) -> i32 {
        let mut first = usize::MAX;
        let mut second = usize::MAX;
        for i in 0..nums.len() {
            if first == usize::MAX || nums[i] > nums[first] {
                second = first;
                first = i;
            } else if second == usize::MAX || nums[i] > nums[second] && i != first {
                second = i;
            }
        }
        if second == usize::MAX || nums[first] >= nums[second] * 2 {first as i32} else {-1}
    }
}
```